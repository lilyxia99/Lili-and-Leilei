<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="description" content="Starter HTML template" />
    <title>My Project</title>

    <!-- External stylesheet -->
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Exo+2:ital,wght@0,100..900;1,100..900&family=Jersey+10&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
    <div id="first-time">This is my first time <br>这是我第一次______</div>
    <div id="options" class="options">
        <button type="button" class="link-button" data-label="content" data-option="This is my first time dating a Chinese" data-content="She eyes are like puppies that drops down, and ">Dating a Chinese</button>
            <button id="second-date" type="button" data-type="replace" data-reveal="false" class="link-button" data-label="content" data-replace-label="first-time" data-replace-content="这是我第一次和女生做爱..." data-content="第二次约会，看完电影之后，我和她回到我的住所。我们在厨房接吻，当晚没有人在房子里，我们上到二楼到我的房间里。我把她推倒在床上，看到她有点错愕又激动的表情，我感觉反而也有点惊慌失措。<br> &quot; I...I actually don't know how to do this&quot;<br>&quot; Is this your first time? &quot;<br>
            &quot;Yeah...I'm sorry. I just, I, I've been wanting to, but I just don't know how... &quot;我有点尴尬，我确实不知道怎么做，以前一直是和直男在一起的我，对这一切都很陌生，对她也很陌生—— 我现在甚至不知道她下面到底是阴道还是阴茎。<br>
            &quot;So I will be your first queer sex. &quot;She smiled, &quot;Well I get to take your 'first time' then. &quot;<br> 
            她用手指轻轻地抚摸着我的脸颊：&quot;We can take it slow, and I will guide you. I just have one request...">和女生做爱</button> 
            <div id="content" aria-live="polite" role="status"></div>
            <button data-pre="second-date" type="button" class="link-button" data-label="one-request" data-content="
            <br> &quot;I've had a lot of people trying to have sex with me on the first or second date, and they kind of disappear. &quot;她看着我的眼睛，眼睑垂下一点， &quot;I hope this is not the last time, we are still going to seeing each other again. &quot;<br>
            我想都没有想就回答，我们肯定是会再见面的。当时的我其实并不理解为什么她会问这样的问题，但后来我会理解，在她的过去体验里，一夜情和 short term relationship是家常便饭。在一起睡觉并不代表就要对对方“负责”。<br>
            我们小心翼翼地开始接吻，开始抚摸彼此的身体。微胖的她身体很柔软，我突然懂得了我前男友说我很好摸是什么意思。我的手滑倒她的胸部——我从来没有触摸过另一个女生的胸部。这种感觉很奇妙，不知道该如何反应，仿佛自己也在被摸，但是不知道这样的通感是否是“正当“的有点像照镜子。<br>
            我掀开她的裙子，逐渐脱下她的内裤，看到里面是阴茎。一定程度上我松了一口气，可能是因为这依旧是我“熟悉的领域”，但这种松了一口气的感觉让我觉得有点愧疚。
            <br>但我不打算让她插入，我告诉她我一直觉得自己有阴道炎。她表示完全没关系。“we can do it the lesbian way then.“<br>
            她把我身体翻过来，用头绳扎起她的头发，开始亲吻我的脖子。
            <br>
            “舒服……”<br>
            “舒服时甚么……？”她停下来，有点害羞地用蹩脚的中文问我。我笑了笑，“it means comfortable.”<br>
            “舒服……”她喃喃地重复着这个词，“我想你舒服……“
            女同的性爱感觉非常忙碌，因为似乎没有一个固定的程序。如果是插入式的，似乎总是有一个明确的开始和结束，但女生之间似乎没有那么明确的界限。我们互相抚摸，亲吻，舔舐对方的身体，一定程度上如果不一直贴着的话：“I feel a little cold.“我很容易感觉冷。但是她似乎完全不受影响，“Oh I'm like a heater.“
            ">Yeah...?<br></button>
            <span data-pre="second-date" id="one-request"></span>
    </div>

    </div>
    

    

        <script>
        (function(){
            const options = document.getElementById('options');
            const question = document.getElementById('first-time');
            const contentEl = document.getElementById('content');

            // Map from preId -> Array of buttons that depend on that pre element
            const preButtonMap = new Map();

            if (!options) return;

            // On load: hide any elements that have `data-pre`, reveal elements
            // that don't, then iteratively reveal `data-pre` elements whose
            // referenced target is already visible. This makes elements without
            // `data-pre` appear first, and dependent elements appear afterwards.
            (function initPreRevealSequence(){
                const children = Array.from(options.children);

                // First pass: register data-pre elements and hide them; reveal others
                children.forEach(el => {
                    const preId = el.dataset && el.dataset.pre;
                    if (preId){
                        const arr = preButtonMap.get(preId) || [];
                        arr.push(el);
                        preButtonMap.set(preId, arr);
                        if (!el.classList.contains('hidden-until-show')) el.classList.add('hidden-until-show');
                    } else {
                        // elements without data-pre should show first
                        el.classList.remove('hidden-until-show');
                        if (!el.classList.contains('show')) el.classList.add('show');
                        // reveal any buttons waiting for this element's id
                        if (el.id) revealButtonsFor(el.id);
                    }
                });

                // NOTE: do not auto-reveal data-pre elements during page load.
                // They should remain hidden (`hidden-until-show`) until their
                // referenced element becomes visible via normal interactions
                // (the `showElement` / `replaceContentWithTransition` paths will
                // call `revealButtonsFor` when elements become visible).
            })();

            function showContent(html){
                if (!contentEl) return;
                contentEl.innerHTML = html || '';
                window.requestAnimationFrame(() => contentEl.classList.add('show'));
            }

            // Replace the main content with transition and return a Promise that
            // resolves when the new content has been shown.
            function replaceContentWithTransition(html){
                return new Promise((resolve) => {
                    if (!contentEl) {
                        showContent(html);
                        return resolve();
                    }

                    function finishShow(){
                        // small async tick so caller sees DOM updated
                        // reveal any buttons waiting for #content
                        revealButtonsFor(contentEl && contentEl.id);
                        window.requestAnimationFrame(() => resolve());
                    }

                    if (contentEl.classList.contains('show')){
                        const onEnd = function(ev){
                            if (ev.propertyName !== 'opacity') return;
                            contentEl.removeEventListener('transitionend', onEnd);
                            showContent(html);
                            // wait for next transition to finish showing the new content
                            const onShowEnd = function(ev2){
                                if (ev2.propertyName !== 'opacity') return;
                                contentEl.removeEventListener('transitionend', onShowEnd);
                                finishShow();
                            };
                            contentEl.addEventListener('transitionend', onShowEnd);
                        };

                        contentEl.addEventListener('transitionend', onEnd);
                        contentEl.classList.remove('show');

                        // fallback if transitionend doesn't fire
                        setTimeout(() => {
                            if (!contentEl.classList.contains('show')){
                                contentEl.removeEventListener('transitionend', onEnd);
                                showContent(html);
                                // resolve shortly after showing
                                setTimeout(finishShow, 50);
                            }
                        }, 700);
                    } else {
                        showContent(html);
                        // wait a tick then resolve (no hide/show cycle needed)
                        setTimeout(finishShow, 50);
                    }
                });
            }

            // Show any element (not necessarily #content). Returns a Promise that
            // resolves when the element is considered visible. If `html` is
            // provided and element is not #content, its innerHTML will be set.
            function showElement(el, html){
                return new Promise((resolve) => {
                    if (!el) return resolve();

                    if (html && el !== contentEl){
                        el.innerHTML = html;
                    }

                    if (el === contentEl){
                        // use content transition helper
                        replaceContentWithTransition(html).then(() => {
                            // reveal any buttons waiting for this element
                            revealButtonsFor(el.id);
                            resolve();
                        });
                        return;
                    }

                    // If already has `show`, consider it visible and reveal buttons
                    if (el.classList.contains('show')){
                        revealButtonsFor(el.id);
                        return resolve();
                    }

                    // Remove hiding class if present, then add `show`. Resolve after
                    // a short delay (allowing CSS transitions if any).
                    el.classList.remove('hidden-until-show');
                    // force reflow for transition to take effect
                    void el.offsetWidth;
                    el.classList.add('show');
                    // If the element has a transition, try to wait for it
                    const computed = window.getComputedStyle(el);
                    const hasTransition = computed.transitionDuration && computed.transitionDuration !== '0s';
                    if (hasTransition){
                        const onEnd = function(ev){
                            el.removeEventListener('transitionend', onEnd);
                            // reveal dependent buttons
                            revealButtonsFor(el.id);
                            resolve();
                        };
                        el.addEventListener('transitionend', onEnd);
                        // fallback
                        setTimeout(() => {
                            revealButtonsFor(el.id);
                            resolve();
                        }, 700);
                    } else {
                        // no transition — resolve after a tiny delay
                        revealButtonsFor(el.id);
                        setTimeout(resolve, 50);
                    }
                });
            }

            // Reveal any buttons that are waiting for a given preId
            function revealButtonsFor(preId){
                if (!preId) return;
                const list = preButtonMap.get(preId) || [];
                list.forEach(btn => {
                    if (!btn.classList.contains('show')){
                        btn.classList.remove('hidden-until-show');
                        // trigger a reflow then show class so any CSS transition can run
                        void btn.offsetWidth;
                        btn.classList.add('show');
                    }
                });
            }

            options.addEventListener('click', function(e) {
                const btn = e.target.closest('button');
                if (!btn) return;

                // DEBUG: log attributes to help trace why elements may not appear
                console.debug('button clicked', { id: btn.id, dataset: { label: btn.dataset.label, pre: btn.dataset.pre, content: !!btn.dataset.content } });

                // New: if this button declares `data-replace-label`, replace the
                // content of the element whose id matches that value with the
                // current button's `data-replace-content` (use transition for #content).
                // Only perform replacement if `data-replace-content` attribute is present
                // to avoid accidentally clearing content when the attribute is missing
                // (common cause: typo like `data-reaplace-content`).
                const replaceLabelAttr = btn.getAttribute('data-replace-label');
                if (replaceLabelAttr && btn.hasAttribute('data-replace-content')){
                    const replaceContent = btn.getAttribute('data-replace-content') ?? '';
                    const replaceEl = document.getElementById(replaceLabelAttr);
                    console.log("replaceEl", replaceEl);
                    if (replaceEl){
                        if (replaceEl === contentEl){
                            // use existing transition helper to replace main content
                            replaceContentWithTransition(replaceContent);
                        } else {
                            replaceEl.innerHTML = replaceContent;
                            // if the replaced element was hidden, reveal it
                            if (replaceEl.classList.contains('hidden-until-show')){
                                replaceEl.classList.remove('hidden-until-show');
                                void replaceEl.offsetWidth;
                                replaceEl.classList.add('show');
                            }
                        }
                    }
                    // After replacement we still allow other behaviours to run
                }

                // If button declares a data-label, use it to find the target element by id
                const label = btn.dataset.label;
                const content = btn.dataset.content ?? btn.dataset.option ?? '';
                const preId = btn.dataset.pre;
                const revealFlag = btn.dataset.reveal === 'true';
                const autoRevealOnClick = btn.dataset.reveal === 'false';
                let showPromise = Promise.resolve();

                if (label){
                    const targetEl = document.getElementById(label);
                    if (!targetEl) return;

                    // If a pre id is provided, ensure the pre element is shown first,
                    // then show the target element. We capture the promise so we can
                    // optionally reveal dependents (data-pre) after completion.
                    if (preId){
                        const preEl = document.getElementById(preId);
                        if (preEl){
                            const preContent = btn.dataset.preContent;
                            if (preContent && (!preEl.innerHTML || preEl.innerHTML.trim() === '')){
                                preEl.innerHTML = preContent;
                            }

                            // Show pre element and wait until it's visible, then show target
                            showPromise = showElement(preEl).then(() => {
                                if (contentEl && targetEl === contentEl){
                                    return replaceContentWithTransition(content);
                                } else {
                                    targetEl.innerHTML = content;
                                    return showElement(targetEl);
                                }
                            });
                        } else {
                            // pre element not found — fallback to showing target immediately
                            if (contentEl && targetEl === contentEl){
                                showPromise = replaceContentWithTransition(content);
                            } else {
                                targetEl.innerHTML = content;
                                showPromise = showElement(targetEl);
                            }
                        }

                        // After the show sequence completes, reveal any dependents if requested
                        if (revealFlag){
                            showPromise.then(() => revealButtonsFor(btn.id));
                        }
                        // If this button had data-reveal="false", flip it to true
                        // after the show completes and reveal dependents for this button id
                        if (autoRevealOnClick){
                            showPromise.then(() => {
                                try{ btn.setAttribute('data-reveal','true'); btn.dataset.reveal = 'true'; }catch(e){}
                                if (btn.id) revealButtonsFor(btn.id);
                            });
                        }

                        return;
                    }

                    // If no preId, proceed as before: show target (with transition for #content)
                    if (contentEl && targetEl === contentEl){
                        showPromise = replaceContentWithTransition(content);
                        if (revealFlag) showPromise.then(() => revealButtonsFor(btn.id));
                        if (autoRevealOnClick){ showPromise.then(() => { try{ btn.setAttribute('data-reveal','true'); btn.dataset.reveal='true'; }catch(e){}; if (btn.id) revealButtonsFor(btn.id); }); }
                        return;
                    }

                    targetEl.innerHTML = content;
                    showPromise = showElement(targetEl);
                    if (revealFlag) showPromise.then(() => revealButtonsFor(btn.id));
                    if (autoRevealOnClick){ showPromise.then(() => { try{ btn.setAttribute('data-reveal','true'); btn.dataset.reveal='true'; }catch(e){}; if (btn.id) revealButtonsFor(btn.id); }); }
                    return;
                }

                // Backwards-compatible behaviour: update the question text and main content
                if (question) question.textContent = btn.dataset.option || '';
                const newHtml = btn.dataset.content || '';
                if (contentEl){
                    const p = replaceContentWithTransition(newHtml);
                    if (revealFlag) p.then(() => revealButtonsFor(btn.id));
                }
            });
        })();
        </script>

</body>
</html>
